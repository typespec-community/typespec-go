import { createTypeSpecLibrary } from "@typespec/compiler";
import { Output } from "@alloy-js/core";
import * as go from "@alloy-js/go";
import { isArrayModelType } from "@typespec/compiler";
import type { EmitContext, Type, Model, Enum, Union, Namespace, ModelProperty } from "@typespec/compiler";
import { GoTypeMapper } from "./utils/type-mapper.js";
import { EmitterConfigFactory, DEFAULT_EMITTER_CONFIG } from "./utils/config.js";
import { ErrorManager } from "./utils/errors.js";

// Create TypeSpec library declaration
export const $lib = createTypeSpecLibrary({
  name: "@typespec-go/emitter",
  diagnostics: {
    "unsupported-type": {
      severity: "error",
      messages: {
        default: "Type '{typeName}' ({kind}) is not yet supported for Go generation.",
      },
    },
  },
} as const);

// Main emission function using proper Alloy Go components
export async function $onEmit(context: EmitContext) {
  try {
    // Create effective configuration
    const config = EmitterConfigFactory.createEffective(context.options);
    
    return (
      <Output>
        <GoModule context={context} config={config} />
      </Output>
    );
    
  } catch (error) {
    // Handle any unexpected errors with our error system
    ErrorManager.handleUnexpectedError({
      message: `Emission failed: ${error instanceof Error ? error.message : String(error)}`,
      cause: error instanceof Error ? error : undefined,
      sourceLocation: {
        file: "emitter.tsx",
        function: "$onEmit",
        line: 0,
        column: 0,
      },
    });
    
    // Re-throw to halt compilation
    throw error;
  }
}

/**
 * Main Go module component using proper Alloy Go components
 */
function GoModule({ context, config }: { context: EmitContext; config: typeof DEFAULT_EMITTER_CONFIG }) {
  // Get global namespace
  const globalNamespace = context.program.getGlobalNamespaceType();
  
  // Collect all types and their imports
  const allModels = Array.from(globalNamespace.models.values());
  const requiredImports = collectRequiredImports(allModels, context);
  
  return (
    <go.ModuleDirectory name="example.com/output">
      <go.SourceDirectory path="api">
        <go.SourceFile path="models.go" package={config.packageName}>
          {config.includeGeneratedWarning && (
            <go.LineComment children="Code generated by TypeSpec Go Emitter" />
          )}
          {config.includeGeneratedWarning && (
            <go.LineComment children="DO NOT EDIT - Generated code" />
          )}
          {config.includeGeneratedWarning && (
            <go.LineComment children="See: https://github.com/typespec-community/typespec-go" />
          )}
          
          {/* TODO: Implement proper imports with ImportStatements */}
          {requiredImports.length > 0 && (
            <go.LineComment children={`TODO: Add imports: ${requiredImports.join(", ")}`} />
          )}
          
          <go.TypeDeclarationGroup children={
            allModels.map((model) => {
              const modelName = String(model.name);
              if (!modelName || model.properties.size === 0) {
                return null;
              }
              return <GoStructDeclaration model={model} context={context} />;
            })
          } />
        </go.SourceFile>
      </go.SourceDirectory>
    </go.ModuleDirectory>
  );
}

/**
 * Collect required imports for all models
 */
function collectRequiredImports(models: Model[], context: EmitContext): string[] {
  const imports = new Set<string>();
  
  for (const model of models) {
    for (const property of model.properties.values()) {
      const goType = GoTypeMapper.mapTypeSpecType(property.type, context.program);
      collectTypeImports(goType, imports);
    }
  }
  
  return Array.from(imports).sort();
}

/**
 * Recursively collect imports from mapped types
 */
function collectTypeImports(mappedType: any, imports: Set<string>): void {
  if (mappedType.importPath) {
    imports.add(mappedType.importPath);
  }
  
  if (mappedType.baseType) {
    collectTypeImports(mappedType.baseType, imports);
  }
  
  if (mappedType.elementType) {
    collectTypeImports(mappedType.elementType, imports);
  }
}

/**
 * Individual type declaration component
 */
function GoTypeDeclaration({ type, context }: { type: Type; context: EmitContext }) {
  switch (type.kind) {
    case "Model":
      // Check if it's an array model
      if (isArrayModelType(context.program, type)) {
        return <GoArrayDeclaration arrayType={type} />;
      }
      return <GoStructDeclaration model={type} context={context} />;
    
    case "Enum":
      return <GoEnumDeclaration enumType={type} />;
    
    default:
      // Log unsupported types
      const typeName = "name" in type ? String(type.name) : "unknown";
      ErrorManager.handleModelGenerationError({
        message: `Unsupported type kind '${type.kind}' for type '${typeName}'`,
        modelName: typeName,
        sourceLocation: {
          file: "emitter.tsx",
          line: 0,
          column: 0,
          function: "GoTypeDeclaration",
        },
        resolution: "Currently only Model, Enum, and Array types are supported",
      });
      return null;
  }
}

/**
 * Go array declaration component using proper Alloy Go components
 */
function GoArrayDeclaration({ arrayType }: { arrayType: Model }) {
  const elementType = GoTypeMapper.mapTypeSpecType(arrayType.indexer!.value);
  const elementTypeName = GoTypeMapper.generateGoTypeString(elementType);
  const arrayName = String(arrayType.name);
  
  return (
    <go.TypeDeclaration name={arrayName}>
      []{elementTypeName}
    </go.TypeDeclaration>
  );
}

/**
 * Go enum declaration component using proper Alloy Go components
 */
function GoEnumDeclaration({ enumType }: { enumType: Enum }) {
  const enumName = String(enumType.name);
  const members = Array.from(enumType.members.values());
  
  return (
    <go.TypeDeclarationGroup children={[
      <go.TypeDeclaration name={enumName}>
        string
      </go.TypeDeclaration>,
      <go.VariableDeclarationGroup const children={
        members.map((member) => (
          <go.VariableDeclaration name={`${enumName}${String(member.name)}`} type={enumName}>
            {`"${String(member.name)}"`}
          </go.VariableDeclaration>
        ))
      } />
    ]} />
  );
}

/**
 * Go struct declaration component using proper Alloy Go components
 */
function GoStructDeclaration({ model, context }: { model: Model; context: EmitContext }) {
  const properties = Array.from(model.properties.values());
  const modelName = String(model.name);
  
  return (
    <go.StructTypeDeclaration name={modelName}>
      {properties.map((property) => (
        <GoStructMember property={property} context={context} />
      ))}
    </go.StructTypeDeclaration>
  );
}

/**
 * Individual struct field component using proper Alloy Go components
 */
function GoStructMember({ property, context }: { property: ModelProperty; context: EmitContext }) {
  const goType = GoTypeMapper.mapTypeSpecType(property.type, context.program);
  const propertyName = String(property.name);
  
  // Generate field name (PascalCase for Go)
  const fieldName = propertyName.charAt(0).toUpperCase() + propertyName.slice(1);
  
  // Generate JSON tag
  const jsonTag = `json:"${propertyName}${property.optional ? ',omitempty' : ''}"`;
  
  // Handle optional types as pointers
  const fieldType = property.optional && (goType.usePointerForOptional ?? false)
    ? <go.Pointer children={goType.name} />
    : goType.name;
  
  return (
    <go.StructMember 
      name={fieldName}
      type={fieldType}
      tag={jsonTag}
    />
  );
}