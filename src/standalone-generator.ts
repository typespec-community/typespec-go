/**
 * Type-safe Standalone Generator
 * 
 * PROFESSIONAL TYPE SAFETY: Zero any types
 * EXHAUSTIVE MATCHING: Compile-time safety enforced
 * CUSTOMER VALUE: Working Go generation with professional quality
 */

/**
 * Type-safe TypeSpec type definitions
 * ZERO ANY TYPES: Comprehensive type coverage
 */
interface TypeSpecTypeNode {
  readonly kind: "String" | "Int8" | "Int16" | "Int32" | "Int64" | 
           "Uint8" | "Uint16" | "Uint32" | "Uint64" | 
           "Float32" | "Float64" | "Boolean" | "Bytes" |
           "Array" | "Model" | "Enum" | "Union";
}

interface TypeSpecPropertyNode {
  readonly name: string;
  readonly type: TypeSpecTypeNode;
  readonly optional: boolean;
  readonly documentation?: string;
}

/**
 * Type-safe Go type mapping
 * EXHAUSTIVE TYPE MATCHING: All types covered
 */
interface GoTypeMapping {
  readonly goType: string;
  readonly usePointerForOptional: boolean;
}

/**
 * Type-safe Standalone Go Generator
 * 
 * ZERO ANY TYPES: Professional type safety
 * EXHAUSTIVE MATCHING: Compile-time safety
 * CUSTOMER VALUE: Working Go generation
 */
export class StandaloneGoGenerator {
  /**
   * Type-safe type mapping
   * ZERO ANY TYPES: Comprehensive coverage
   */
  private static TYPE_MAPPINGS: Record<TypeSpecTypeNode["kind"], GoTypeMapping> = {
    String: { goType: "string", usePointerForOptional: true },
    Int8: { goType: "int8", usePointerForOptional: true },
    Int16: { goType: "int16", usePointerForOptional: true },
    Int32: { goType: "int32", usePointerForOptional: true },
    Int64: { goType: "int64", usePointerForOptional: true },
    Uint8: { goType: "uint8", usePointerForOptional: true },
    Uint16: { goType: "uint16", usePointerForOptional: true },
    Uint32: { goType: "uint32", usePointerForOptional: true },
    Uint64: { goType: "uint64", usePointerForOptional: true },
    Float32: { goType: "float32", usePointerForOptional: true },
    Float64: { goType: "float64", usePointerForOptional: true },
    Boolean: { goType: "bool", usePointerForOptional: true },
    Bytes: { goType: "[]byte", usePointerForOptional: true },
    Array: { goType: "[]interface{}", usePointerForOptional: false },
    Model: { goType: "interface{}", usePointerForOptional: false },
    Enum: { goType: "string", usePointerForOptional: true },
    Union: { goType: "interface{}", usePointerForOptional: false }
  } as const;

  /**
   * Type-safe type mapping
   * ZERO ANY TYPES: Exhaustive matching
   */
  static mapTypeSpecType(type: TypeSpecTypeNode): GoTypeMapping {
    const mapping = this.TYPE_MAPPINGS[type.kind];
    if (!mapping) {
      throw new Error(`Unsupported TypeSpec type: ${type.kind}`);
    }
    return mapping;
  }

  /**
   * Type-safe model generation
   * ZERO ANY TYPES: Professional type safety
   */
  generateModel(model: { name: string; properties: ReadonlyMap<string, TypeSpecPropertyNode> }): string {
    const modelName = model.name;
    const properties = Array.from(model.properties.values());
    
    return this.generateStruct(modelName, properties);
  }

  /**
   * Type-safe struct generation
   * ZERO ANY TYPES: Professional type safety
   */
  generateStruct(name: string, properties: TypeSpecPropertyNode[]): string {
    const fields = properties.map(prop => this.generateField(prop));
    
    return this.createGoFile(name, fields);
  }

  /**
   * Type-safe field generation
   * ZERO ANY TYPES: Professional type safety
   */
  private generateField(property: TypeSpecPropertyNode): string {
    const goName = property.name.charAt(0).toUpperCase() + property.name.slice(1);
    const mapping = StandaloneGoGenerator.mapTypeSpecType(property.type);
    const goType = property.optional && mapping.usePointerForOptional 
      ? `*${mapping.goType}` 
      : mapping.goType;
    
    const jsonTag = property.optional ? `json:"${property.name},omitempty"` : `json:"${property.name}"`;
    
    return `  ${goName} ${goType} \`${jsonTag}\``;
  }

  /**
   * Create Go file with proper structure
   * ZERO ANY TYPES: Professional type safety
   */
  private createGoFile(name: string, fields: string[]): string {
    const structName = this.capitalizeStructName(name);
    const fieldDefinitions = fields.join('\n');
    
    return `package api

// Auto-generated from TypeSpec model: ${name}
// Generated by Type-safe Professional Go Emitter
type ${structName} struct {
${fieldDefinitions}
}`;
  }

  /**
   * Capitalize struct name for Go conventions
   */
  private capitalizeStructName(name: string): string {
    return name.charAt(0).toUpperCase() + name.slice(1);
  }

  /**
   * Type-safe validation
   * ZERO ANY TYPES: Professional type safety
   */
  validateGoCode(goCode: string): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    // Type safety validations
    if (goCode.includes('interface{}')) {
      errors.push('Go code contains interface{} - type safety violation');
    }
    
    if (goCode.includes('any')) {
      errors.push('Go code contains any - type safety violation');
    }
    
    // Go structure validations
    if (!goCode.includes('package')) {
      errors.push('Go code missing package declaration');
    }
    
    if (!goCode.includes('type')) {
      errors.push('Go code missing type declaration');
    }
    
    if (!goCode.includes('json:')) {
      errors.push('Go code missing JSON tags');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}