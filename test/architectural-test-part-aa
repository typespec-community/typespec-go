/**
 * Type-Safe Architecture Validation Test
 *
 * COMPREHENSIVE VALIDATION:
 * - Zero 'any' types
 * - Exhaustive type matching
 * - Unified optional handling
 * - Complete uint support
 * - Type safety throughout
 */
import { strictEqual } from "node:assert";
import { describe, it } from "node:test";
// Test type-safe components directly
import { TYPE_SPEC_MAPPINGS, TypeSafeMapper } from "../src/mappers/type-safe-mapper.js";
import { OptionalFieldPolicy } from "../src/policies/optional-field-policy.js";
import { TypeSafeGoGenerator } from "../src/type-safe-generator.js";
describe("TypeSpec Go Emitter - Type-Safe Architecture Validation", () => {
    // =======================
    // CRITICAL TYPE SAFETY TESTS
    // =======================
    it("ZERO 'any' TYPES: All type mappings are type-safe", () => {
        console.log("ðŸ”¥ TESTING: Zero 'any' types in type mappings");
        // Check all mappings for 'any' contamination
        const mappingString = JSON.stringify(TYPE_SPEC_MAPPINGS);
        const hasAnyTypes = mappingString.includes('any');
        strictEqual(hasAnyTypes, false, "Type mappings should contain zero 'any' types");
        // Verify specific mappings
        const stringMapping = TYPE_SPEC_MAPPINGS.String;
        const uint32Mapping = TYPE_SPEC_MAPPINGS.Uint32;
        strictEqual(typeof stringMapping.goType, "string", "String mapping should have typed goType");
        strictEqual(typeof stringMapping.usePointerForOptional, "boolean", "String mapping should have typed usePointerForOptional");
        strictEqual(typeof uint32Mapping.goType, "string", "Uint32 mapping should have typed goType");
        strictEqual(typeof uint32Mapping.usePointerForOptional, "boolean", "Uint32 mapping should have typed usePointerForOptional");
        console.log("âœ… PASSED: Zero 'any' types in all mappings");
    });
    it("EXHAUSTIVE TYPE MATCHING: All TypeSpec kinds have mappings", () => {
        console.log("ðŸ”¥ TESTING: Exhaustive type matching");
        const requiredKinds = [
            "String", "Int8", "Int16", "Int32", "Int64",
            "Uint8", "Uint16", "Uint32", "Uint64",
            "Float32", "Float64", "Boolean", "Bytes",
            "Array", "Model", "Enum", "Union"
        ];
        const availableKinds = Object.keys(TYPE_SPEC_MAPPINGS);
        requiredKinds.forEach(kind => {
            const hasMapping = availableKinds.includes(kind);
            strictEqual(hasMapping, true, `Should have mapping for ${kind} type`);
        });
        console.log(`âœ… PASSED: All ${requiredKinds.length} TypeSpec kinds have mappings`);
    });
    it("COMPLETE UINT SUPPORT: All unsigned integers supported", () => {
        console.log("ðŸ”¥ TESTING: Complete uint support");
        const uintTypes = ["Uint8", "Uint16", "Uint32", "Uint64"];
        const expectedGoTypes = ["uint8", "uint16", "uint32", "uint64"];
        uintTypes.forEach((uintType, index) => {
            const mapping = TYPE_SPEC_MAPPINGS[uintType];
            strictEqual(mapping.goType, expectedGoTypes[index], `${uintType} should map to ${expectedGoTypes[index]}`);
            strictEqual(mapping.usePointerForOptional, true, `${uintType} should use pointer for optional`);
        });
        console.log("âœ… PASSED: Complete uint support with correct Go types");
    });
    // =======================
    // UNIFIED OPTIONAL HANDLING TESTS
    // =======================
    it("UNIFIED OPTIONAL HANDLING: No split brain - pointer + JSON together", () => {
        console.log("ðŸ”¥ TESTING: Unified optional handling (no split brain)");
        // Test optional property
        const optionalProperty = {
            name: "email",
            type: { kind: "String" },
            optional: true
        };
        const goField = OptionalFieldPolicy.generateField(optionalProperty);
        // Critical: Should have unified optional handling
        strictEqual(goField.name, "Email", "Should capitalize field name");
        strictEqual(goField.type, "*string", "Should use pointer for optional string");
        strictEqual(goField.jsonTag, 'json:"email",omitempty', "Should add omitempty for optional");
        // Critical: No split brain validation
        const hasPointer = goField.type.includes('*');
        const hasOmitempty = goField.jsonTag.includes('omitempty');
        strictEqual(hasPointer && hasOmitempty, true, "Should have unified pointer + JSON handling (no split brain)");
        console.log("âœ… PASSED: Unified optional handling with zero split brain");
    });
    it("REQUIRED PROPERTY HANDLING: No pointer, no omitempty", () => {
        console.log("ðŸ”¥ TESTING: Required property handling");
        // Test required property
        const requiredProperty = {
            name: "name",
            type: { kind: "String" },
            optional: false
        };
        const goField = OptionalFieldPolicy.generateField(requiredProperty);
        // Should have no optional handling
        strictEqual(goField.name, "Name", "Should capitalize field name");
        strictEqual(goField.type, "string", "Should not use pointer for required");
        strictEqual(goField.jsonTag, 'json:"name"', "Should not add omitempty for required");
        // Critical: No split brain validation
        const hasPointer = goField.type.includes('*');
        const hasOmitempty = goField.jsonTag.includes('omitempty');
        strictEqual(!hasPointer && !hasOmitempty, true, "Should have no optional handling for required (no split brain)");
